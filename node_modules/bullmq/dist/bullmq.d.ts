/// <reference types="node" />
import { ChildProcess } from 'child_process';
import { Cluster } from 'ioredis';
import { EventEmitter } from 'events';
import * as IORedis from 'ioredis';
import { Redis } from 'ioredis';
import { RedisOptions as RedisOptions_2 } from 'ioredis';

export declare interface AdvancedOptions {
    /**
     * A set of custom backoff strategies keyed by name.
     */
    backoffStrategies?: {};
}

export declare const AdvancedOptionsDefaults: AdvancedOptions;

export declare type BackoffFunction = (attemptsMade?: number, err?: Error) => number;

/**
 * Settings for backing off failed jobs.
 *
 * @see {@link https://docs.bullmq.io/guide/retrying-failing-jobs}
 */
export declare interface BackoffOptions {
    /**
     * Name of the backoff strategy.
     */
    type: string;
    /**
     * Delay in milliseconds.
     */
    delay?: number;
}

export declare class Backoffs {
    static builtinStrategies: BuiltInStrategies;
    static normalize(backoff: number | BackoffOptions): BackoffOptions;
    static calculate(backoff: BackoffOptions, attemptsMade: number, customStrategies: Strategies, err: Error): number;
}

declare interface BuiltInStrategies {
    [index: string]: (delay: number) => BackoffFunction;
}

export declare class ChildPool {
    retained: {
        [key: number]: ChildProcessExt;
    };
    free: {
        [key: string]: ChildProcessExt[];
    };
    constructor();
    retain(processFile: string): Promise<ChildProcessExt>;
    release(child: ChildProcessExt): void;
    remove(child: ChildProcessExt): void;
    kill(child: ChildProcess, signal?: 'SIGTERM' | 'SIGKILL'): Promise<void>;
    clean(): Promise<void>;
    getFree(id: string): ChildProcessExt[];
    getAllFree(): ChildProcessExt[];
}

export declare interface ChildProcessExt extends ChildProcess {
    processFile?: string;
}

export declare const clientCommandMessageReg: RegExp;

export declare enum ClientType {
    blocking = "blocking",
    normal = "normal"
}

export declare type ConnectionOptions = RedisOptions | Redis | Cluster;

export declare interface FlowJob {
    name: string;
    queueName: string;
    data?: any;
    prefix?: string;
    opts?: Omit<JobsOptions, 'parent'>;
    children?: FlowJob[];
}

/**
 * This class allows to add jobs into one or several queues
 * with dependencies between them in such a way that it is possible
 * to build complex flows.
 */
export declare class FlowProducer extends EventEmitter {
    opts: QueueBaseOptions;
    toKey: (name: string, type: string) => string;
    keys: KeysMap;
    closing: Promise<void>;
    queueKeys: QueueKeys;
    protected connection: RedisConnection;
    constructor(opts?: QueueBaseOptions);
    /**
     * Adds a flow.
     *
     * A flow is a tree-like structure of jobs that depend on each other.
     * Whenever the children of a given parent are completed, the parent
     * will be processed, being able to access the children's result data.
     *
     * All Jobs can be in different queues, either children or parents,
     * however this call would be atomic, either it fails and no jobs will
     * be added to the queues, or it succeeds and all jobs will be added.
     *
     * @param flow An object with a tree-like structure where children jobs
     * will be processed before their parents.
     */
    add(flow: FlowJob): Promise<JobNode>;
    /**
     * Add a node (job) of a flow to the queue. This method will recursively
     * add all its children as well. Note that a given job can potentially be
     * a parent and a child job at the same time depending on where it is located
     * in the tree hierarchy.
     *
     * @param multi ioredis pipeline
     * @param node the node representing a job to be added to some queue
     * @param parent Parent data sent to children to create the "links" to their parent
     * @returns
     */
    private addNode;
    private addChildren;
    /**
     * Helper factory method that creates a queue-like object
     * required to create jobs in any queue.
     *
     * @param node
     * @param queueKeys
     * @returns
     */
    private queueFromNode;
    close(): Promise<void>;
    disconnect(): Promise<void>;
}

export declare interface GetNextJobOptions {
    block?: boolean;
}

export declare function getParentKey(opts: {
    id: string;
    queue: string;
}): string;

export declare class Job<T = any, R = any, N extends string = string> {
    private queue;
    name: N;
    data: T;
    opts: JobsOptions;
    id?: string;
    progress: number | object;
    returnvalue: R;
    stacktrace: string[];
    timestamp: number;
    attemptsMade: number;
    failedReason: string;
    finishedOn?: number;
    processedOn?: number;
    /**
     * Fully qualified key pointing to the parent of this job.
     */
    parentKey?: string;
    private toKey;
    private discarded;
    constructor(queue: MinimalQueue, name: N, data: T, opts?: JobsOptions, id?: string);
    static create<T = any, R = any, N extends string = string>(queue: MinimalQueue, name: N, data: T, opts?: JobsOptions): Promise<Job<T, R, N>>;
    static createBulk<T = any, R = any, N extends string = string>(queue: MinimalQueue, jobs: {
        name: N;
        data: T;
        opts?: JobsOptions;
    }[]): Promise<Job<T, R, N>[]>;
    static fromJSON(queue: MinimalQueue, json: JobJsonRaw, jobId?: string): Job<any, any, string>;
    static fromId(queue: MinimalQueue, jobId: string): Promise<Job | undefined>;
    toJSON(): Pick<this, Exclude<keyof this, "queue">>;
    asJSON(): JobJson;
    update(data: T): Promise<void>;
    updateProgress(progress: number | object): Promise<void>;
    /**
     * Logs one row of log data.
     *
     * @params logRow: string String with log data to be logged.
     *
     */
    log(logRow: string): Promise<number>;
    remove(): Promise<void>;
    /**
     * Extend the lock for this job.
     *
     * @param token unique token for the lock
     * @param duration lock duration in milliseconds
     */
    extendLock(token: string, duration: number): Promise<any>;
    /**
     * Moves a job to the completed queue.
     * Returned job to be used with Queue.prototype.nextJobFromJobData.
     * @param returnValue {string} The jobs success message.
     * @param fetchNext {boolean} True when wanting to fetch the next job
     * @returns {Promise} Returns the jobData of the next job in the waiting queue.
     */
    moveToCompleted(returnValue: R, token: string, fetchNext?: boolean): Promise<[JobJsonRaw, string] | []>;
    /**
     * Moves a job to the failed queue.
     * @param err {Error} The jobs error message.
     * @param token {string} Token to check job is locked by current worker
     * @param fetchNext {boolean} True when wanting to fetch the next job
     * @returns void
     */
    moveToFailed(err: Error, token: string, fetchNext?: boolean): Promise<void>;
    isCompleted(): Promise<boolean>;
    isFailed(): Promise<boolean>;
    isDelayed(): Promise<boolean>;
    isWaitingChildren(): Promise<boolean>;
    isActive(): Promise<boolean>;
    isWaiting(): Promise<boolean>;
    /**
     * Get current state.
     * @method
     * @returns {string} Returns one of these values:
     * 'completed', 'failed', 'delayed', 'active', 'waiting', 'waiting-children', 'unknown'.
     */
    getState(): Promise<any>;
    /**
     * Get this jobs children result values if any.
     *
     * @returns Object mapping children job keys with their values.
     */
    getChildrenValues<CT = any>(): Promise<{
        [jobKey: string]: CT;
    }>;
    /**
     * Get children job keys if this job is a parent and has children.
     *
     * @returns dependencies separated by processed and unprocessed.
     */
    getDependencies(): Promise<{
        processed: {
            [jobKey: string]: string;
        };
        unprocessed: string[];
    }>;
    /**
     * Returns a promise the resolves when the job has finished. (completed or failed).
     */
    waitUntilFinished(queueEvents: QueueEvents, ttl?: number): Promise<R>;
    moveToDelayed(timestamp: number): Promise<void>;
    promote(): Promise<void>;
    /**
     * Attempts to retry the job. Only a job that has failed can be retried.
     *
     * @return {Promise} If resolved and return code is 1, then the queue emits a waiting event
     * otherwise the operation was not a success and throw the corresponding error. If the promise
     * rejects, it indicates that the script failed to execute
     */
    retry(state?: 'completed' | 'failed'): Promise<void>;
    discard(): void;
    private isInZSet;
    private isInList;
    addJob(client: Redis, parentOpts?: ParentOpts): string;
    private saveAttempt;
}

export declare interface JobJson {
    id: string;
    name: string;
    data: string;
    opts: string;
    progress: number | object;
    attemptsMade: number;
    finishedOn?: number;
    processedOn?: number;
    timestamp: number;
    failedReason: string;
    stacktrace: string;
    returnvalue: string;
    parentKey?: string;
}

export declare interface JobJsonRaw {
    id: string;
    name: string;
    data: string;
    opts: string;
    progress: string;
    attemptsMade: string;
    finishedOn?: string;
    processedOn?: string;
    timestamp: string;
    failedReason: string;
    stacktrace: string[];
    returnvalue: string;
    parentKey?: string;
}

export declare interface JobNode {
    job: Job;
    children?: JobNode[];
}

export declare interface JobsOptions {
    /**
     * Defaults to `Date.now()`
     */
    timestamp?: number;
    /**
     * Ranges from 1 (highest priority) to MAX_INT (lowest priority). Note that
     * using priorities has a slight impact on performance,
     * so do not use it if not required.
     */
    priority?: number;
    /**
     * An amount of milliseconds to wait until this job can be processed.
     * Note that for accurate delays, worker and producers
     * should have their clocks synchronized.
     */
    delay?: number;
    /**
     * The total number of attempts to try the job until it completes.
     */
    attempts?: number;
    /**
     * Repeat this job, for example based on a `cron` schedule.
     */
    repeat?: RepeatOptions;
    /**
     * Rate limiter key to use if rate limiter enabled.
     *
     * @see {@link https://docs.bullmq.io/guide/rate-limiting}
     */
    rateLimiterKey?: string;
    /**
     * Backoff setting for automatic retries if the job fails
     */
    backoff?: number | BackoffOptions;
    /**
     * If true, adds the job to the right of the queue instead of the left (default false)
     *
     * @see {@link https://docs.bullmq.io/guide/jobs/lifo}
     */
    lifo?: boolean;
    /**
     * The number of milliseconds after which the job should be
     * fail with a timeout error.
     */
    timeout?: number;
    /**
     * Override the job ID - by default, the job ID is a unique
     * integer, but you can use this setting to override it.
     * If you use this option, it is up to you to ensure the
     * jobId is unique. If you attempt to add a job with an id that
     * already exists, it will not be added.
     */
    jobId?: string;
    /**
     * If true, removes the job when it successfully completes
     * When given an number, it specifies the maximum amount of
     * jobs to keep.
     * Default behavior is to keep the job in the completed set.
     */
    removeOnComplete?: boolean | number;
    /**
     * If true, removes the job when it fails after all attempts.
     * When given an number, it specifies the maximum amount of
     * jobs to keep.
     */
    removeOnFail?: boolean | number;
    /**
     * Limits the amount of stack trace lines that will be recorded in the stacktrace.
     */
    stackTraceLimit?: number;
    /**
     *
     */
    parent?: {
        id: string;
        queue: string;
    };
    /**
     * Internal property used by repeatable jobs.
     */
    prevMillis?: number;
}

declare type KeysMap = {
    [index in string]: string;
};

export declare const load: (client: Redis) => Promise<void>;

export declare type MinimalQueue = Pick<QueueBase, 'client' | 'toKey' | 'keys' | 'opts' | 'closing' | 'waitUntilReady' | 'removeListener' | 'emit' | 'on' | 'redisVersion'>;

export declare type ParentOpts = {
    waitChildrenKey?: string;
    parentDependenciesKey?: string;
    parentKey?: string;
};

/**
 * An async function that receives `Job`s and handles them.
 */
export declare type Processor<T = any, R = any, N extends string = string> = (job: Job<T, R, N>, token?: string) => Promise<R>;

export declare class Queue<T = any, R = any, N extends string = string> extends QueueGetters {
    token: string;
    jobsOpts: JobsOptions;
    limiter: {
        groupKey: string;
    };
    private _repeat;
    constructor(name: string, opts?: QueueOptions);
    get defaultJobOptions(): JobsOptions;
    get repeat(): Promise<Repeat>;
    add(name: N, data: T, opts?: JobsOptions): Promise<Job<T, R, N>>;
    private jobIdForGroup;
    /**
     * Adds an array of jobs to the queue.
     * @method add
     * @param jobs: [] The array of jobs to add to the queue. Each job is defined by 3
     * properties, 'name', 'data' and 'opts'. They follow the same signature as 'Queue.add'.
     */
    addBulk<ParentDataType>(jobs: {
        name: N;
        data: T;
        opts?: JobsOptions;
    }[]): Promise<Job<T, any, N>[]>;
    /**
      Pauses the processing of this queue globally.
  
      We use an atomic RENAME operation on the wait queue. Since
      we have blocking calls with BRPOPLPUSH on the wait queue, as long as the queue
      is renamed to 'paused', no new jobs will be processed (the current ones
      will run until finalized).
  
      Adding jobs requires a LUA script to check first if the paused list exist
      and in that case it will add it there instead of the wait list.
    */
    pause(): Promise<void>;
    resume(): Promise<void>;
    isPaused(): Promise<boolean>;
    getRepeatableJobs(start?: number, end?: number, asc?: boolean): Promise<{
        key: string;
        name: string;
        id: string;
        endDate: number;
        tz: string;
        cron: string;
        next: number;
    }[]>;
    removeRepeatable(name: N, repeatOpts: RepeatOptions, jobId?: string): Promise<any>;
    removeRepeatableByKey(key: string): Promise<any>;
    /**
     * Removes the given job from the queue as well as all its
     * dependencies.
     *
     * @param jobId The if of the job to remove
     * @returns 1 if it managed to remove the job or -1 if the job or
     * any of its dependencies was locked.
     */
    remove(jobId: string): Promise<any>;
    /**
     * Drains the queue, i.e., removes all jobs that are waiting
     * or delayed, but not active, completed or failed.
     *
     * TODO: Convert to an atomic LUA script.
     */
    drain(delayed?: boolean): Promise<[Error, any][]>;
    clean(grace: number, limit: number, type?: 'completed' | 'wait' | 'active' | 'paused' | 'delayed' | 'failed'): Promise<any>;
    obliterate(opts?: {
        force?: boolean;
        count?: number;
    }): Promise<void>;
    trimEvents(maxLength: number): Promise<number>;
}

export declare class QueueBase extends EventEmitter {
    readonly name: string;
    opts: QueueBaseOptions;
    toKey: (type: string) => string;
    keys: KeysMap;
    closing: Promise<void>;
    protected connection: RedisConnection;
    constructor(name: string, opts?: QueueBaseOptions);
    get client(): Promise<IORedis.Redis>;
    get redisVersion(): string;
    waitUntilReady(): Promise<IORedis.Redis>;
    protected base64Name(): string;
    protected clientName(): string;
    close(): Promise<void>;
    disconnect(): Promise<void>;
}

export declare interface QueueBaseOptions {
    connection?: ConnectionOptions;
    /**
     * Prefix for all queue keys.
     */
    prefix?: string;
}

export declare interface QueueEvents {
    on(event: 'waiting', listener: (args: {
        jobId: string;
    }, id: string) => void): this;
    on(event: 'delayed', listener: (args: {
        jobId: string;
        delay: number;
    }, id: string) => void): this;
    on(event: 'progress', listener: (args: {
        jobId: string;
        data: string;
    }, id: string) => void): this;
    on(event: 'stalled', listener: (args: {
        jobId: string;
    }, id: string) => void): this;
    on(event: 'completed', listener: (args: {
        jobId: string;
        returnvalue: string;
        prev?: string;
    }, id: string) => void): this;
    on(event: 'failed', listener: (args: {
        jobId: string;
        failedReason: string;
        prev?: string;
    }, id: string) => void): this;
    on(event: 'removed', listener: (args: {
        jobId: string;
    }, id: string) => void): this;
    on(event: 'drained', listener: (id: string) => void): this;
    on(event: string, listener: Function): this;
}

export declare class QueueEvents extends QueueBase {
    constructor(name: string, opts?: QueueEventsOptions);
    private consumeEvents;
    close(): Promise<void>;
}

export declare interface QueueEventsOptions extends QueueBaseOptions {
    lastEventId?: string;
    blockingTimeout?: number;
}

export declare class QueueGetters extends QueueBase {
    getJob(jobId: string): Promise<Job | undefined>;
    private commandByType;
    /**
      Returns the number of jobs waiting to be processed.
    */
    count(): Promise<number>;
    getJobCountByTypes(...types: string[]): Promise<number>;
    /**
     * Returns the job counts for each type specified or every list/set in the queue by default.
     *
     */
    getJobCounts(...types: string[]): Promise<{
        [index: string]: number;
    }>;
    getCompletedCount(): Promise<number>;
    getFailedCount(): Promise<number>;
    getDelayedCount(): Promise<number>;
    getActiveCount(): Promise<number>;
    getWaitingCount(): Promise<number>;
    getWaitingChildrenCount(): Promise<number>;
    getWaiting(start?: number, end?: number): Promise<Job<any, any, string>[]>;
    getWaitingChildren(start?: number, end?: number): Promise<Job<any, any, string>[]>;
    getActive(start?: number, end?: number): Promise<Job<any, any, string>[]>;
    getDelayed(start?: number, end?: number): Promise<Job<any, any, string>[]>;
    getCompleted(start?: number, end?: number): Promise<Job<any, any, string>[]>;
    getFailed(start?: number, end?: number): Promise<Job<any, any, string>[]>;
    getRanges(types: string[], start?: number, end?: number, asc?: boolean): Promise<any[]>;
    getJobs(types: string[] | string, start?: number, end?: number, asc?: boolean): Promise<Job<any, any, string>[]>;
    getJobLogs(jobId: string, start?: number, end?: number): Promise<{
        logs: any;
        count: any;
    }>;
    getWorkers(): Promise<{
        [index: string]: string;
    }[]>;
    private parseClientList;
}

declare class QueueKeys {
    readonly prefix: string;
    constructor(prefix?: string);
    getKeys(name: string): KeysMap;
    toKey(name: string, type: string): string;
    getPrefixedQueueName(name: string): string;
}

export declare interface QueueOptions extends QueueBaseOptions {
    defaultJobOptions?: JobsOptions;
    limiter?: {
        groupKey: string;
    };
    streams?: {
        events: {
            /**
             * Max aproximated length for streams
             */
            maxLen: number;
        };
    };
}

/**
 * This class is just used for some automatic bookkeeping of the queue,
 * such as updating the delay set as well as moving stalled jobs back
 * to the waiting list.
 *
 * Jobs are checked for stallness once every "visibility window" seconds.
 * Jobs are then marked as candidates for being stalled, in the next check,
 * the candidates are marked as stalled and moved to wait.
 * Workers need to clean the candidate list with the jobs that they are working
 * on, failing to update the list results in the job ending being stalled.
 *
 * This class requires a dedicated redis connection, and at least one is needed
 * to be running at a given time, otherwise delays, stalled jobs, retries, repeatable
 * jobs, etc, will not work correctly or at all.
 *
 */
export declare class QueueScheduler extends QueueBase {
    private nextTimestamp;
    private isBlocked;
    constructor(name: string, { connection, ...opts }?: QueueSchedulerOptions);
    private run;
    private readDelayedData;
    private updateDelaySet;
    private moveStalledJobsToWait;
    close(): Promise<void>;
}

/**
 * Options for customizing the behaviour of the scheduler.
 *
 * @see {@link https://docs.bullmq.io/guide/jobs/stalled}
 * @see {@link https://docs.bullmq.io/guide/queuescheduler}
 */
export declare interface QueueSchedulerOptions extends QueueBaseOptions {
    /**
     * Amount of times a job can be recovered from a stalled state
     * to the `wait` state. If this is exceeded, the job is moved
     * to `failed`.
     */
    maxStalledCount?: number;
    /**
     * Number of milliseconds between stallness checks.
     */
    stalledInterval?: number;
}

export declare interface RateLimiterOptions {
    /**
     * Max number of jobs to process in the time period
     * specified in `duration`.
     */
    max: number;
    /**
     * Time in milliseconds. During this time, a maximum
     * of `max` jobs will be processed.
     */
    duration: number;
    /**
     * It is possible to define a rate limiter based on group keys,
     * for example you may want to have a rate limiter per customer
     * instead of a global rate limiter for all customers
     *
     * @see {@link https://docs.bullmq.io/guide/rate-limiting}
     */
    groupKey?: string;
    /**
     * This option enables a heuristic so that when a queue is heavily
     * rete limited, it delays the workers so that they do not try
     * to pick jobs when there is no point in doing so.
     * Note: It is not recommended to use this option when using
     * groupKeys unless you have a big amount of workers since
     * you may be delaying workers that could pick jobs in groups that
     * have not been rate limited.
     */
    workerDelay?: boolean;
}

export declare class RedisConnection extends EventEmitter {
    private opts?;
    static minimumVersion: string;
    private _client;
    private initializing;
    private closing;
    private version;
    constructor(opts?: ConnectionOptions);
    /**
     * Waits for a redis client to be ready.
     * @param {Redis} redis client
     */
    static waitUntilReady(client: IORedis.Redis): Promise<void>;
    get client(): Promise<IORedis.Redis>;
    private init;
    disconnect(): Promise<void>;
    reconnect(): Promise<void>;
    close(): Promise<void>;
    private getRedisVersion;
    get redisVersion(): string;
}

export declare type RedisOptions = RedisOptions_2 & {
    skipVersionCheck?: boolean;
};

export declare class Repeat extends QueueBase {
    addNextRepeatableJob<T = any, R = any, N extends string = string>(name: N, data: T, opts: JobsOptions, skipCheckExists?: boolean): Promise<Job<T, R, N>>;
    private createNextJob;
    removeRepeatable(name: string, repeat: RepeatOptions, jobId?: string): Promise<any>;
    removeRepeatableByKey(repeatJobKey: string): Promise<any>;
    _keyToData(key: string): {
        key: string;
        name: string;
        id: string;
        endDate: number;
        tz: string;
        cron: string;
    };
    getRepeatableJobs(start?: number, end?: number, asc?: boolean): Promise<{
        key: string;
        name: string;
        id: string;
        endDate: number;
        tz: string;
        cron: string;
        next: number;
    }[]>;
    getRepeatableCount(): Promise<number>;
}

/**
 * Settings for repeatable jobs
 *
 * @see {@link https://docs.bullmq.io/guide/jobs/repeatable}
 */
export declare interface RepeatOptions {
    /**
     * A cron pattern
     */
    cron?: string;
    /**
     * Timezone
     */
    tz?: string;
    /**
     * Start date when the repeat job should start repeating (only with `cron`).
     */
    startDate?: Date | string | number;
    /**
     * End date when the repeat job should stop repeating.
     */
    endDate?: Date | string | number;
    /**
     * Number of times the job should repeat at max.
     */
    limit?: number;
    /**
     * Repeat after this amount of milliseconds
     * (`cron` setting cannot be used together with this setting.)
     */
    every?: number;
    /**
     * The start value for the repeat iteration count.
     */
    count?: number;
    prevMillis?: number;
    jobId?: string;
}

export declare enum RetryErrors {
    JobNotFailed = -2,
    JobIsActive = -1,
    JobNotExist = 0
}

/**
 * @see {@link https://docs.bullmq.io/guide/workers/sandboxed-processors}
 */
export declare interface SandboxedJob<T = any, R = any> extends Omit<JobJson, 'data' | 'opts' | 'progress' | 'log' | 'returnValue'> {
    data: T;
    opts: JobsOptions;
    progress: (() => object | number) | ((value: object | number) => Promise<void>);
    log: (row: any) => void;
    returnValue: R;
}

/**
 * @see {@link https://docs.bullmq.io/guide/workers/sandboxed-processors}
 */
export declare type SandboxedJobProcessor<T = any, R = any> = ((job: SandboxedJob<T, R>) => R | PromiseLike<R>) | ((job: SandboxedJob<T, R>, callback: (error: unknown, result: R) => void) => void);

export declare class Scripts {
    static isJobInList(queue: MinimalQueue, listKey: string, jobId: string): Promise<boolean>;
    static addJob(client: Redis, queue: MinimalQueue, job: JobJson, opts: JobsOptions, jobId: string, parentOpts?: ParentOpts): any;
    static pause(queue: MinimalQueue, pause: boolean): Promise<any>;
    static remove(queue: MinimalQueue, jobId: string): Promise<any>;
    static extendLock(queue: MinimalQueue, jobId: string, token: string, duration: number): Promise<any>;
    static updateProgress(queue: MinimalQueue, job: Job, progress: number | object): Promise<void>;
    static moveToFinishedArgs(queue: MinimalQueue, job: Job, val: any, propVal: string, shouldRemove: boolean | number, target: string, token: string, fetchNext?: boolean): string[];
    static moveToFinished(queue: MinimalQueue, job: Job, val: any, propVal: string, shouldRemove: boolean | number, target: string, token: string, fetchNext: boolean): Promise<[] | [JobJsonRaw, string]>;
    static finishedErrors(code: number, jobId: string, command: string): Error;
    static moveToCompleted(queue: MinimalQueue, job: Job, returnvalue: any, removeOnComplete: boolean | number, token: string, fetchNext: boolean): Promise<[] | [JobJsonRaw, string]>;
    static moveToFailedArgs(queue: MinimalQueue, job: Job, failedReason: string, removeOnFailed: boolean | number, token: string, fetchNext?: boolean): string[];
    static isFinished(queue: MinimalQueue, jobId: string): Promise<any>;
    static getState(queue: MinimalQueue, jobId: string): Promise<any>;
    static moveToDelayedArgs(queue: MinimalQueue, jobId: string, timestamp: number): string[];
    static moveToDelayed(queue: MinimalQueue, jobId: string, timestamp: number): Promise<void>;
    static cleanJobsInSet(queue: MinimalQueue, set: string, timestamp: number, limit?: number): Promise<any>;
    static retryJobArgs(queue: MinimalQueue, job: Job): string[];
    /**
     * Attempts to reprocess a job
     *
     * @param {Job} job
     * @param {Object} options
     * @param {String} options.state The expected job state. If the job is not found
     * on the provided state, then it's not reprocessed. Supported states: 'failed', 'completed'
     *
     * @return {Promise<Number>} Returns a promise that evaluates to a return code:
     * 1 means the operation was a success
     * 0 means the job does not exist
     * -1 means the job is currently locked and can't be retried.
     * -2 means the job was not found in the expected set
     */
    static reprocessJob(queue: MinimalQueue, job: Job, state: 'failed' | 'completed'): Promise<any>;
    static moveToActive<T, R, N extends string>(worker: Worker<T, R, N>, token: string, jobId?: string): Promise<[] | [number, undefined] | [JobJsonRaw, string]>;
    static updateDelaySet(queue: MinimalQueue, delayedTimestamp: number): Promise<any>;
    static promote(queue: MinimalQueue, jobId: string): Promise<any>;
    static moveStalledJobsToWait(queue: QueueScheduler): Promise<any>;
    static obliterate(queue: MinimalQueue, opts: {
        force: boolean;
        count: number;
    }): Promise<any>;
}

export declare interface Strategies {
    [index: string]: BackoffFunction;
}

export declare class Worker<T = any, R = any, N extends string = string> extends QueueBase {
    opts: WorkerOptions;
    private drained;
    private waiting;
    private processFn;
    private resumeWorker;
    private paused;
    private _repeat;
    private childPool;
    private timerManager;
    private blockingConnection;
    private processing;
    constructor(name: string, processor?: string | Processor<T, R, N>, opts?: WorkerOptions);
    waitUntilReady(): Promise<Redis>;
    get repeat(): Promise<Repeat>;
    private run;
    /**
     * Returns a promise that resolves to the next job in queue.
     * @param token worker token to be assigned to retrieved job
     * @returns a Job or undefined if no job was available in the queue.
     */
    getNextJob(token: string, { block }?: GetNextJobOptions): Promise<Job<any, any, string>>;
    private moveToActive;
    private waitForJob;
    private nextJobFromJobData;
    processJob(job: Job<T, R, N>, token: string): Promise<void | Job<any, any, string>>;
    /**
     * Pauses the processing of this queue only for this worker.
     */
    pause(doNotWaitActive?: boolean): Promise<void>;
    resume(): void;
    isPaused(): boolean;
    /**
     * Returns a promise that resolves when active jobs are cleared
     *
     * @returns {Promise}
     */
    private whenCurrentJobsFinished;
    close(force?: boolean): Promise<void>;
}

export declare interface WorkerOptions extends QueueBaseOptions {
    /**
     * Amount of jobs that a single worker is allowed to work on
     * in parallel.
     *
     * @see {@link https://docs.bullmq.io/guide/workers/concurrency}
     */
    concurrency?: number;
    /**
     * @see {@link https://docs.bullmq.io/guide/rate-limiting}
     */
    limiter?: RateLimiterOptions;
    skipDelayCheck?: boolean;
    drainDelay?: number;
    lockDuration?: number;
    lockRenewTime?: number;
    settings?: AdvancedOptions;
}

export { }
